import json
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.output_parsers import ResponseSchema, StructuredOutputParser

class MultiAgentSystem:
    def __init__(self, vector_store):
        self.llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
        self.vector_store = vector_store

    def _get_rag_context(self, table_fingerprint):
        """ä¸ºè¡¨ä¸­çš„æ¯ä¸€åˆ—æ£€ç´¢ RAG ä¸Šä¸‹æ–‡"""
        context = ""
        table_data = table_fingerprint
        for col in table_data['columns']:
            # æ£€ç´¢ä¸ åˆ—å+æ ·æœ¬ ç›¸å…³çš„æœ¯è¯­
            query = f"Column: {col['name']}, Samples: {', '.join(col['samples'][:3])}"
            results = self.vector_store.search(query, k=3)
            context += f"\nColumn '{col['name']}' potential matches:\n"
            for doc in results:
                context += f"  - {doc.metadata['uri']} ({doc.page_content[:50]}...)\n"
        return context

    def run_mapping_agent(self, table_fingerprint):
        """Mapping Agent: æ˜ å°„åˆ—åˆ° Schema.org"""
        print("ğŸ¤– Mapping Agent æ­£åœ¨å·¥ä½œ...")
        rag_context = self._get_rag_context(table_fingerprint)
        
        prompt = ChatPromptTemplate.from_template("""
        You are an expert Semantic Mapping Agent. 
        Your goal is to map relational database columns to Schema.org properties/classes.
        
        Input Data (Table Fingerprint):
        {table_json}

        Ontology Knowledge (RAG Context):
        {rag_context}

        Instructions:
        1. Analyze the column name and sample values.
        2. Choose the best matching URI from Schema.org (use the RAG context).
        3. If no good match exists, output null.
        
        Return ONLY a JSON object: {{ "column_name": "schema_uri" }}
        """)
        
        chain = prompt | self.llm
        response = chain.invoke({
            "table_json": json.dumps(table_fingerprint), 
            "rag_context": rag_context
        })
        return json.loads(response.content)

    def run_relation_agent(self, table_fingerprint):
        """Relation Agent: è¯†åˆ«ä¸»å¤–é”®"""
        print("ğŸ¤– Relation Agent æ­£åœ¨å·¥ä½œ...")
        prompt = ChatPromptTemplate.from_template("""
        Analyze the table structure to identify Primary Keys (PK) and likely Foreign Keys (FK).
        FKs usually end in '_id' or match other table names (though you only see one table here, guess based on naming).
        
        Table Data:
        {table_json}
        
        Return ONLY JSON: {{ "pk": "column_name", "fks": ["col1", "col2"] }}
        """)
        chain = prompt | self.llm
        response = chain.invoke({"table_json": json.dumps(table_fingerprint)})
        return json.loads(response.content)

    def run_validator_agent(self, table_fingerprint, mapping, relations):
        """Validator Agent: å®¡æŸ¥å¹¶ä¿®æ­£ [åˆ›æ–°ç‚¹]"""
        print("ğŸ•µï¸ Validator Agent æ­£åœ¨å®¡æŸ¥...")
        prompt = ChatPromptTemplate.from_template("""
        You are a Knowledge Graph Quality Assurance expert.
        Review the mapping generated by previous agents.
        
        Table: {table_name}
        Proposed Mapping: {mapping}
        Proposed Relations: {relations}
        
        Rules:
        1. Ensure the URI is a valid Schema.org term.
        2. If a column is a Foreign Key, it should likely be mapped to an ObjectProperty (relationship), not a DataType property.
        
        Output the FINAL corrected JSON mapping.
        """)
        chain = prompt | self.llm
        response = chain.invoke({
            "table_name": table_fingerprint['table_name'],
            "mapping": json.dumps(mapping),
            "relations": json.dumps(relations)
        })
        return json.loads(response.content)